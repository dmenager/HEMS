(ql:quickload :hems)
(in-package :hems)

(defun position-example ()
  (let (bn1 bn2 bn3)
    (setq bn1 (compile-program nil
		c1 = (percept-node x_pos_prev :value "1")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c2 = (percept-node x_vel :value "1")
		c2 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c3 = (percept-node time_delta :value "2")
		c4 = (percept-node y_pos_prev :value "2")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c5 = (percept-node y_vel :value "1")
		c5 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c6 = (functional-node x_pos
				      :arguments (c1 c2 c3)
				      :generator
				      (let (new-mean domain domain-ints max-d min-d)
					(setq domain '("1" "2" "3" "4" "5" "6" "7" "8" "9"))
					(setq domain-ints (mapcar #'parse-integer domain))
					(setq max-d (apply #'max domain-ints))
					(setq min-d (apply #'min domain-ints))
					(cond ((some #'(lambda (arg)
							 (string-equal "na" arg))
						     (list c1 c2 c3))
					       (loop
						 for d in domain
						 collect (cons d 0) into result
						 finally (return result)))
					      (t
					       (setq new-mean (round (+ (* (parse-integer c2)
									   (parse-integer c3))
									(parse-integer c1))))
					       (when nil
						 (format t "~%~%x_pos_prev: ~d~%x_vel: ~d~%new x_pos mean: ~d" c1 c2 new-mean))
					       (cond ((> new-mean max-d)
						      (setq new-mean max-d))
						     ((< new-mean min-d)
						      (setq new-mean min-d)))
					       (when nil
						 (format t "~%bounded mean: ~d" new-mean))
					       (setq new-mean (write-to-string new-mean))
					       (mapcar #'(lambda (value-list)
							   (cons (getf value-list :value)
								 (getf value-list :probability)))
						       (discrete-normal-approximation :values domain
										      :modes (list new-mean))))))
				      :type "percept")))
    (setq bn2 (compile-program nil
		c1 = (percept-node x_pos_prev :value "3")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c2 = (percept-node x_vel :value "-1")
		c2 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c3 = (percept-node time_delta :value "2")
		c4 = (percept-node y_pos_prev :value "2")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c5 = (percept-node y_vel :value "1")
		c5 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c6 = (functional-node x_pos
				      :arguments (c1 c2 c3)
				      :generator
				      (let (new-mean domain domain-ints max-d min-d)
					(setq domain '("1" "2" "3" "4" "5" "6" "7" "8" "9"))
					(setq domain-ints (mapcar #'parse-integer domain))
					(setq max-d (apply #'max domain-ints))
					(setq min-d (apply #'min domain-ints))
					(cond ((some #'(lambda (arg)
							 (string-equal "na" arg))
						     (list c1 c2 c3))
					       (loop
						 for d in domain
						 collect (cons d 0) into result
						 finally (return result)))
					      (t
					       (setq new-mean (round (+ (* (parse-integer c2)
									   (parse-integer c3))
									(parse-integer c1))))
					       (when nil
						 (format t "~%~%x_pos_prev: ~d~%x_vel: ~d~%new x_pos mean: ~d" c1 c2 new-mean))
					       (cond ((> new-mean max-d)
						      (setq new-mean max-d))
						     ((< new-mean min-d)
						      (setq new-mean min-d)))
					       (when nil
						 (format t "~%bounded mean: ~d" new-mean))
					       (setq new-mean (write-to-string new-mean))
					       (mapcar #'(lambda (value-list)
							   (cons (getf value-list :value)
								 (getf value-list :probability)))
						       (discrete-normal-approximation :values domain
										      :modes (list new-mean))))))
				      :type "percept")))
    (setq bn3 (compile-program nil
		c1 = (percept-node x_pos_prev :value "5")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c2 = (percept-node x_vel :value "-1")
		c2 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c3 = (percept-node time_delta :value "2")
		c4 = (percept-node y_pos_prev :value "2")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6" "7" "8" "9"))
		c5 = (percept-node y_vel :value "1")
		c2 ~ (discrete-uniform :values ("1" "-1" "2" "3"))
		c6 = (functional-node x_pos
				      :arguments (c1 c2 c3)
				      :generator
				      (let (new-mean domain domain-ints max-d min-d)
					(setq domain '("1" "2" "3" "4" "5" "6" "7" "8" "9"))
					(setq domain-ints (mapcar #'parse-integer domain))
					(setq max-d (apply #'max domain-ints))
					(setq min-d (apply #'min domain-ints))
					(cond ((some #'(lambda (arg)
							 (string-equal "na" arg))
						     (list c1 c2 c3))
					       (loop
						 for d in domain
						 collect (cons d 0) into result
						 finally (return result)))
					      (t
					       (setq new-mean (round (+ (* (parse-integer c2)
									   (parse-integer c3))
									(parse-integer c1))))
					       (when nil
						 (format t "~%~%x_pos_prev: ~d~%x_vel: ~d~%new x_pos mean: ~d" c1 c2 new-mean))
					       (cond ((> new-mean max-d)
						      (setq new-mean max-d))
						     ((< new-mean min-d)
						      (setq new-mean min-d)))
					       (when nil
						 (format t "~%bounded mean: ~d" new-mean))
					       (setq new-mean (write-to-string new-mean))
					       (mapcar #'(lambda (value-list)
							   (cons (getf value-list :value)
								 (getf value-list :probability)))
						       (discrete-normal-approximation :values domain
										      :modes (list new-mean))))))
				      :type "percept")))
    (loop
      with insert-p = t
      for obs in (list bn1 bn2 bn3)
      for i from 0
      do
	 (new-push-to-ep-buffer :observation obs :hidden-state-p nil :insertp t :temporal-p nil)	 
      finally
	 (hems:eltm-to-pdf)
	 (hems:print-bn (episode-observation (car hems:eltm*))))))

(defun functional-cpd ()
  (let (bn1 bn2 bn3)
    (setq bn1 (compile-program nil
		c1 = (percept-node road_index1 :value "1")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c2 = (functional-node road_dist_1
				      :arguments (c1)
				      :generator
				      (cond ((equal c1 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c1 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c1 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c1 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c3 = (percept-node decision_1 :value "2")
		c4 = (percept-node road_index2 :value "2")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c5 = (functional-node road_dist_2
				      :arguments (c4)
				      :generator
				      (cond ((equal c4 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c4 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c4 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c4 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c6 = (percept-node decision_2 :value "4")
		c2 --> c3
		c5 --> c6
		c3 --> c6))
    (setq bn2 (compile-program nil
		c1 = (percept-node road_index1 :value "2")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c2 = (functional-node road_dist_1
				      :arguments (c1)
				      :generator
				      (cond ((equal c1 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c1 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c1 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c1 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c3 = (percept-node decision_1 :value "4")
		c4 = (percept-node road_index2 :value "4")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c5 = (functional-node road_dist_2
				      :arguments (c4)
				      :generator
				      (cond ((equal c4 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c4 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c4 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c4 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c6 = (percept-node decision_2 :value "5")
		c2 --> c3
		c5 --> c6
		c3 --> c6))
    (setq bn3 (compile-program nil
		c1 = (percept-node road_index1 :value "4")
		c1 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c2 = (functional-node road_dist_1
				      :arguments (c1)
				      :generator
				      (cond ((equal c1 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c1 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c1 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c1 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c1 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c3 = (percept-node decision_1 :value "5")
		c4 = (percept-node road_index2 :value "5")
		c4 ~ (discrete-uniform :values ("1" "2" "3" "4" "5" "6"))
		c5 = (functional-node road_dist_2
				      :arguments (c4)
				      :generator
				      (cond ((equal c4 "1")
					     (list (cons "1" 0)
						   (cons "2" 1/3)
						   (cons "3" 1/3)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 1/3)))
					    ((equal c4 "2")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "3")
					     (list (cons "1" 1/3)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/3)
						   (cons "6" 1/3)))
					    ((equal c4 "4")
					     (list (cons "1" 0)
						   (cons "2" 1/2)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 1/2)
						   (cons "6" 0)))
					    ((equal c4 "5")
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 1/2)
						   (cons "5" 0)
						   (cons "6" 0)))
					    ((equal c4 "6")
					     (list (cons "1" 1/2)
						   (cons "2" 0)
						   (cons "3" 1/2)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0)))
					    (t
					     (list (cons "1" 0)
						   (cons "2" 0)
						   (cons "3" 0)
						   (cons "4" 0)
						   (cons "5" 0)
						   (cons "6" 0))))
				      :type "RELATION")
		c6 = (percept-node decision_2 :value "3")
		c2 --> c3
		c5 --> c6
		c3 --> c6))
    (loop
      with insert-p = t
      for obs in (list bn1 bn2 bn3)
      for i from 0
      do
	 (new-push-to-ep-buffer :observation obs :hidden-state-p nil :insertp t :temporal-p nil)
	 (hems:eltm-to-pdf)
	 (hems:print-bn (episode-observation (car hems:eltm*)))
	 (when t
	   (format t "~%inserting bn:")
	   (hems::print-bn obs)
	   (break))
      )))

(defun example ()
  (let (observations obs)
    (setq obs (compile-program nil
		c1 = (percept-node road_index_1 :value "nil")
		c2 = (percept-node road_dist_1 :value "nil")
		c3 = (percept-node decision_1 :value "nil")
		c4 = (percept-node road_index_2 :value "nil")
		c5 = (percept-node road_dist_2 :value "nil")
		c6 = (percept-node decision_2 :value "nil")))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_1 :value "road1")
			       c2 = (percept-node road_dist_1 :value "road2")
			       c3 = (percept-node decision_1 :value "road2")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_1 :value "road1")
			       c2 = (percept-node road_dist_1 :value "road3")
			       c3 = (percept-node decision_1 :value "road2")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_1 :value "road1")
			       c2 = (percept-node road_dist_1 :value "road4")
			       c3 = (percept-node decision_1 :value "road2")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_2 :value "road2")
			       c2 = (percept-node road_dist_2 :value "road1")
			       c3 = (percept-node decision_2 :value "road3")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_2 :value "road2")
			       c2 = (percept-node road_dist_2 :value "road3")
			       c3 = (percept-node decision_2 :value "road3")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
			       c1 = (percept-node road_index_2 :value "road2")
			       c2 = (percept-node road_dist_2 :value "road4")
			       c3 = (percept-node decision_2 :value "road3")
			       c1 --> c2
			       c2 --> c3))
    (setq observations (cons obs observations))

    (setq obs (compile-program nil
		c1 = (percept-node decision_1 :value "road2")
		c2 = (percept-node decision_2 :value "road3")
		c1 --> c2))
    (setq observations (cons obs observations))
    (loop
	  with insert-p = t
	  for obs in (reverse observations)
	  for i from 0
	  do
	  (new-push-to-ep-buffer :observation obs :hidden-state-p nil :insertp t :temporal-p nil)
	  (hems:eltm-to-pdf)
	  (hems:print-bn (episode-observation (car hems:eltm*)))
	  ;;(break)
	  )))
